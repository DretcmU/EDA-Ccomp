// Alexander Carpio Mamani - Lab 07 Pthreads
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <ctype.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>

#define MAX_THREADS 100
 
pthread_t threads[MAX_THREADS];
int thread_count = 0;
int thread_ids[MAX_THREADS];
int running_threads = 1;
 
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
 
int is_positive_integer(const char *str) {
    if (*str == '\0') return 0;
    for (int i = 0; str[i]; i++) {
        if (!isdigit(str[i])) return 0;
    }
    return atoi(str) > 0;
}

int fibonacci(int n) {
    return n<=1 ? n : fibonacci(n - 1) + fibonacci(n - 2);
}

void* print_name(void* arg) {
    int id = *(int*)arg;
    printf("Thread ID: %d - My name is Alexande\n", id);
    pthread_exit(NULL);
}
 

void* print_fibonacci(void* arg) {
    int id = thread_ids[thread_count - 1];
    int n = *(int*)arg;
    free(arg);
 
    int result = fibonacci(n);
    if (pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL) == 0) {
        printf("Thread ID: %d - Fibonacci Number for %d: %d\n", id, n, result);
   }
 
    pthread_exit(NULL);
}
 
void* endprom(void* arg){
    //printf("a");
    for (int i = 0; i < thread_count; i++) {
        pthread_cancel(threads[i]);
    }

    for (int i = 0; i < thread_count; i++) {
        pthread_join(threads[i], NULL);
    }

    printf("All threads terminated. Exiting program.\n");

    //kill(getpid(), SIGTERM);
}

void create_thread(void* (*func)(void*), void* arg) {
    if (thread_count >= MAX_THREADS) {
        printf("Error: número máximo de hilos alcanzado.\n");
        return;
    }
 
    pthread_mutex_lock(&mutex);
    thread_ids[thread_count] = thread_count;
    pthread_create(&threads[thread_count], NULL, func, arg);
    thread_count++;
    pthread_mutex_unlock(&mutex);
}
 
int main() {
    char input[100];
 
    while (running_threads) {
        printf("\nEnter your choice:\n1. Print name.\n2. Print i-th Fibonacci number.\n3. Exit program.\n");
        fgets(input, sizeof(input), stdin);
 
        input[strcspn(input, "\n")] = 0; // quita el salto de cada entrada.
 
        if (strcmp(input, "1") == 0) {
            int* id = malloc(sizeof(int));
            *id = thread_count;
            create_thread(print_name, id);
 
        } else if (strcmp(input, "2") == 0) {
            printf("Enter the position for Fibonacci number: ");
            fgets(input, sizeof(input), stdin);
            input[strcspn(input, "\n")] = 0;
 
            if (is_positive_integer(input)) {
                int* n = malloc(sizeof(int));
                *n = atoi(input);
                create_thread(print_fibonacci, n);
            } else {
                printf("Invalid\n");
            }
 
        } else if (strcmp(input, "3") == 0) {
            create_thread(endprom,input);
            running_threads = 0;
 
        } else {
            printf("Error: Invalid input. Please enter 1, 2 or 3.\n");
        }
    }
 
    return 0;
}
 
}



// Alexander Carpio Mamani
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char **argv)
{
    if (argc == 2)
    {
        int VA_bits = 32;

        // 4 KB => 2^12 = 4096 bytes
        int page_size = 4096;
        int offset_bits = 12;

        unsigned int vaddr = atoi(argv[1]);


        // Al desplazar 12 bits a la derecha, eliminamos los bits del offset
        // y nos quedamos con los bits del número de página, equivalente a dividir VA/2^12(offset).
        // | 20 bits para page number | 12 bits para offset |
        unsigned int page_number = vaddr >> offset_bits;

        // page_size - 1: porque las direcciones van de 0 a 4995, las siguientes memorias van de 4996 para adelante.
        // y usamos el '&' para verificar los 12 ultimos bits de la virtualaddress
        /*
        mask    =      0000 1111 1111 1111
        vaddr   = 0001 0001 0010 1011 0101
        &       -------------------------
        result  =      0000 0010 1011 0101 = 0x2B5 = 693
        */
        // y usamos el '&' en vez de un '%', ya que es mas eficiente y hace menos calculos, ya que tabaja con procesos binarios y menos instrucciones.
        unsigned int offset = vaddr & (page_size - 1); // o (1 << 12) - 1

        printf("VA Size[%d] Bits\n", VA_bits);
        printf("Page Size is [4KB][%dbits]\n", offset_bits);
        printf("The address [%u] = [%Xh] contains:\n", vaddr, vaddr);
        printf("page number = [%u] = [%Xh]\n", page_number, page_number);
        printf("offset = [%u] = [%Xh]\n", offset, offset);
    }
    else
    {
        printf("Usage: ./program <virtual address (decimal)>\n");
    }

    return 0;
}


#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

#define BUFFER_SIZE 5
#define NUM_PRODUCERS 3
#define NUM_CONSUMERS 3
#define ITEMS_PER_THREAD 5

int buffer[BUFFER_SIZE];
int count = 0;

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;

void* producer(void* arg) {
    int id = *(int*)arg;
    for (int i = 0; i < ITEMS_PER_THREAD; i++) {
        pthread_mutex_lock(&mutex);

        while (count == BUFFER_SIZE) {
            pthread_cond_wait(&cond, &mutex);
        }

        int item = id * 100 + i;
        buffer[count++] = item;
        printf("Producer %d produced: %d (count=%d)\n", id, item, count);

        pthread_cond_broadcast(&cond); // Despertar a consumidores y productores
        pthread_mutex_unlock(&mutex);

        usleep(rand() % 500000); // Simula trabajo o para que no corran todos
    }
    return NULL;
}

void* consumer(void* arg) {
    int id = *(int*)arg;
    for (int i = 0; i < ITEMS_PER_THREAD; i++) {
        pthread_mutex_lock(&mutex);

        while (count == 0) {
            pthread_cond_wait(&cond, &mutex);
        }

        int item = buffer[--count];
        printf("Consumer %d consumed: %d (count=%d)\n", id, item, count);

        pthread_cond_broadcast(&cond);
        pthread_mutex_unlock(&mutex);

        usleep(rand() % 500000);
    }
    return NULL;
}

int main() {
    pthread_t producers[NUM_PRODUCERS], consumers[NUM_CONSUMERS];
    int ids[NUM_PRODUCERS > NUM_CONSUMERS ? NUM_PRODUCERS : NUM_CONSUMERS];

    for (int i = 0; i < NUM_PRODUCERS; i++) {
        ids[i] = i + 1;
        pthread_create(&producers[i], NULL, producer, &ids[i]);
    }

    for (int i = 0; i < NUM_CONSUMERS; i++) {
        ids[i] = i + 1;
        pthread_create(&consumers[i], NULL, consumer, &ids[i]);
    }

    for (int i = 0; i < NUM_PRODUCERS; i++) {
        pthread_join(producers[i], NULL);
    }

    for (int i = 0; i < NUM_CONSUMERS; i++) {
        pthread_join(consumers[i], NULL);
    }

    return 0;
}


#include <pthread.h>
#include <semaphore.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <sys/types.h>
#include <time.h>
#include <unistd.h>

void *barber_function(void *idp);
void *customer_function(void *idp);
void serve_customer();
void *make_customer_function();

sem_t barber_ready;
sem_t customer_ready;
sem_t modifySeats;

int chair_cnt;
int total_custs;

int available_seats;
int no_served_custs = 0;
time_t waiting_time_sum;

void *barber_function(void *idp) {
  while (1) {
    sem_wait(&customer_ready); // Espera a un cliente
    sem_wait(&modifySeats);
    available_seats++;
    sem_post(&barber_ready); // Barber listo
    sem_post(&modifySeats);

    printf("\n[Barber] Available_seats: %d.\n", available_seats);
    printf("[Barber] Customer was served.\n");

    serve_customer();
  }
  pthread_exit(NULL);
}

void *customer_function(void *idp) {
  sem_wait(&modifySeats);
  if (available_seats > 0) {
    available_seats--;
    sem_post(&customer_ready); // Notifica llegada
    sem_post(&modifySeats);

    printf("[Customer pid = %lu] is waiting. Available seats: %d\n",
           pthread_self(), available_seats);

    sem_wait(&barber_ready); // Espera al barbero

    printf("[Customer pid = %lu] is being served.\n", pthread_self());
  } else {
    sem_post(&modifySeats);
    no_served_custs++;
    printf("[Customer pid = %lu] left. Available_seats: %d.\n", pthread_self(),
           available_seats);
  }

  pthread_exit(NULL);
}

void serve_customer() {
  int s = rand() % 401;
  s = s * 1000;
  usleep(s);
}

void *make_customer_function() {
  int tmp;
  int counter = 0;

  while (counter < total_custs) {
    pthread_t customer_thread;

    tmp =
        pthread_create(&customer_thread, NULL, (void *)customer_function, NULL);

    if (tmp)
      printf("Failed to create thread.\n");

    counter++;
    usleep(100000); // 100ms
  }

  pthread_exit(NULL);
}

int main(int argc, char *argv[]) {
  if (argc != 3)
    printf("Command Line Argumentes should be: ./program <number_of_seats> "
           "<number_of_customers>\n");
  else {
    chair_cnt = atoi(argv[1]);
    total_custs = atoi(argv[2]);

    srand(time(NULL));

    pthread_t barber_1;
    pthread_t customer_maker;
    int tmp;

    sem_init(&customer_ready, 0, 0);
    sem_init(&barber_ready, 0, 0);
    sem_init(&modifySeats, 0, 1);

    available_seats = chair_cnt;

    tmp = pthread_create(&barber_1, NULL, (void *)barber_function, NULL);
    if (tmp)
      printf("Failed to create barber thread.\n");

    tmp = pthread_create(&customer_maker, NULL, (void *)make_customer_function,
                         NULL);
    if (tmp)
      printf("Failed to create customer_maker thread.\n");

    pthread_join(barber_1, NULL);
    pthread_join(customer_maker, NULL);

    printf("\n------------------------------------------------\n");
    printf("Number of served customers: %d\n", (total_custs - no_served_custs));
    printf("Number of customers that were forced to leave: %d\n",
           no_served_custs);
  }
}



 1. Manejo de Swap (Swapping)
Es la técnica de mover procesos entre memoria principal y disco para liberar espacio.
Ejemplo: Si no hay memoria suficiente, un proceso inactivo se “swapea” al disco (área de swap) y luego se trae de nuevo cuando se necesita.

📌 2. Swapping Policies (Políticas de intercambio)
Determinan cuándo y qué procesos se deben mover al swap.

FIFO: el más antiguo se mueve primero.

Least Recently Used (LRU): el que no se usó por más tiempo.

Prioridad: procesos con baja prioridad son enviados a swap.

📌 3. Padding
En sistemas, padding se refiere a relleno adicional que se usa para:

Alinear datos en memoria para mayor eficiencia.

Evitar conflictos de acceso (por ejemplo, alineación a 4 bytes).

También se usa en sistemas de archivos para completar bloques.

📌 4. Semáforos
Son variables especiales que permiten controlar el acceso concurrente a recursos compartidos en sistemas con múltiples procesos o hilos.

sem_wait(): bloquea si el recurso no está disponible.

sem_post(): libera el recurso.
Útiles para evitar condiciones de carrera y asegurar sincronización.

📌 5. Rendezvous
Es una técnica de sincronización uno-a-uno entre dos procesos o hilos.
Ambos deben llegar a cierto punto para poder continuar.
Ejemplo: un cliente y un servidor deben estar listos al mismo tiempo para realizar una operación.

📌 6. Problema del barbero dormido
Modelo clásico de sincronización:

Un barbero duerme si no hay clientes.

Clientes llegan y se van si no hay sillas libres.

Se usa semáforos para controlar acceso a la silla y la sala de espera.

📌 7. Bus Station Problem (Estación de buses)
Un problema de concurrencia donde se sincronizan:

Pasajeros que esperan en una estación.

Un bus que llega y permite que suban hasta que se llena o no quedan más pasajeros.

Necesario: control de acceso concurrente con semáforos y condiciones.

📌 8. Problema de los filósofos comensales
Cinco filósofos comparten una mesa y tenedores. Cada uno:

Piensa.

Quiere comer y necesita 2 tenedores (el de la izquierda y el de la derecha).
Problema: evitar interbloqueos y inanición.
Soluciones:

Semáforos para evitar tomar tenedores si no hay dos disponibles.

Jerarquía en adquisición de tenedores.

📌 9. Disco (Gestión de disco)
El sistema operativo debe:

Organizar archivos en sectores del disco.

Minimizar el tiempo de búsqueda (seek time).

Algoritmos de planificación de disco:

FCFS

SSTF (el más cercano primero)

SCAN (ascensor)

LOOK (como SCAN pero sin ir al final)

📌 10. Máquinas Virtuales (VMs)
Permiten ejecutar varios sistemas operativos sobre una misma máquina física.
Tipos:

VM completas (como VirtualBox): emulan hardware.

Contenedores (como Docker): comparten el núcleo pero aíslan entornos.

Ventajas:

Aislamiento

Portabilidad

Ahorro de recursos
